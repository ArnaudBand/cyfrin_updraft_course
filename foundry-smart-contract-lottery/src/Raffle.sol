// SPDX-License-Identifier: UNLICENSEDpragma solidity ^0.8.0;import {VRFCoordinatorV2Interface} from "@chainlink/contracts/src/v0.8/interfaces/VRFCoordinatorV2Interface.sol";import {VRFConsumerBaseV2} from "@chainlink/contracts/src/v0.8/vrf/VRFConsumerBaseV2.sol";/** * @title A simple Raffle Contract * @author Arnaud * @notice This contract is for creating a sample raffle * @dev Implements Chainlink VRFv2 */contract Raffle is VRFConsumerBaseV2 {    error Raffle__NotEnoughEthSent();    error Raffle__TransferFailed();    uint16 private constant REQUEST_CONFIRMATIONS = 3;    uint32 private constant NUM_WORDS = 1;    uint256 private immutable i_entranceFee;    uint256 private immutable i_interval;    VRFCoordinatorV2Interface private immutable i_vrfCoordinator;    bytes32 private immutable i_gasLane;    uint64 private immutable i_subscriptionId;    uint32 private immutable i_callbackGasLimit;    uint256 private s_lastTimeStamp;    address payable[] private s_players;    address private s_recentWinner;    /**     * Events     */    event Enteredraffle(address indexed player);    constructor(        uint256 entranceFee,        uint256 _interval,        address _vrfCoordinator,        bytes32 _gasLane,        uint64 _subscriptionId,        uint32 _callbackGasLimit    ) VRFConsumerBaseV2(_vrfCoordinator) {        i_entranceFee = entranceFee;        i_interval = _interval;        i_vrfCoordinator = VRFCoordinatorV2Interface(_vrfCoordinator);        i_gasLane = _gasLane;        i_subscriptionId = _subscriptionId;        i_callbackGasLimit = _callbackGasLimit;        s_lastTimeStamp = block.timestamp;    }    function enterRaffle() external payable {        if (msg.value < i_entranceFee) revert Raffle__NotEnoughEthSent();        s_players.push(payable(msg.sender));        emit Enteredraffle(msg.sender);    }    function pickWinner() external {        if ((block.timestamp - s_lastTimeStamp) < i_interval) revert();        uint256 requestId = i_vrfCoordinator.requestRandomWords(            i_gasLane, i_subscriptionId, REQUEST_CONFIRMATIONS, i_callbackGasLimit, NUM_WORDS        );    }    function fulfillRandomWords(uint256 requestId, uint256[] memory randomWord) internal override {        uint256 indexOfWinner = randomWord[0] % s_players.length;        address payable winner = s_players[indexOfWinner];        s_recentWinner = winner;        (bool success, ) = winner.call{value: address(this).balance}("");        if(!success) revert Raffle__TransferFailed();    }    /**     * Getter function     */    function getEntranceFee() external view returns (uint256) {        return i_entranceFee;    }}